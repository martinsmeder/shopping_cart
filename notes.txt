==================================== Testing ==================================
Mocking child-components: https://medium.com/@taylormclean15/jest-testing-mocking-child-components-to-make-your-unit-tests-more-concise-18691ef6a0c2
Queries: https://testing-library.com/docs/queries/about/
Cheatsheet: https://testing-library.com/docs/dom-testing-library/cheatsheet/
ID's: https://testing-library.com/docs/queries/bytestid/
User event's: https://testing-library.com/docs/user-event/intro/

Prioritize High-Impact Areas:
Identify the most critical and complex parts of your application. Components 
that handle critical user interactions, data processing, or have complex logic 
are excellent candidates for testing.

Unit Testing:
Focus on unit tests for individual components and functions. These tests are 
generally easier to write, maintain, and run. They help you catch issues early 
in the development process.

===================================== Router ==================================
Tutorial: https://reactrouter.com/en/main/start/tutorial
Docs: https://reactrouter.com/en/main

================================== Fetching Data ==============================
Performance: https://www.developerway.com/posts/how-to-fetch-data-in-react

Avoiding "waterfall of requests":
The "waterfall of requests" refers to a situation in web development where 
multiple HTTP requests are made sequentially or one after another, often 
triggered by the completion of the previous request. This can be problematic for
several reasons, one being negative impact on performance as latency adds up 
for each request. 
1. Batch requests an concurrency methods (like promise.All)
2. Data cashing: Use client side libraries like Redux for example. 
3. Pagination: For large datasets. 
